from typing import List, Optional, Any, Sequence
import sqlalchemy
import json

from coolNewLanguage.src.cell import Cell
from coolNewLanguage.src.component.input_component import InputComponent
from coolNewLanguage.src.row import Row
from coolNewLanguage.src.stage import process, config
from coolNewLanguage.src.util.db_utils import update_cell, get_table_names_from_tool, get_column_names_from_table_name, \
    iterate_over_column, get_rows_of_table


class ColumnSelectorComponent(InputComponent):
    """
    A linked, dependent component which allows a column to be selected
    interactively based on a given selected table

    If created before their associated TableSelectorComponent, ColumnSelectors must be passed as a list when the
    TableSelectorComponent is initialized.
    If created after their associated TableSelectorComponent, ColumnSelectors must:
        1. Have the register_on_table_selector(table) method called on the associated TableSelectorComponent
        2. Be appended to the TableSelectorComponent's columns attribute
    For convenience, the create_column_selector_from_table_selector can be used

    Attributes:
        table_selector: The TableSelector representing the table from which a column is being selected
        label: The label to paint onto this ColumnSelector
        emulated_row_id: The id of the row this selector currently represents, used when during execution of certain
            Processors
        emulated_column: The name of the column this selector represents
        expected_val_type: The expected type of the values contained in this column
    """
    def __init__(self, label: Optional[str] = None, expected_val_type: Optional[type] = None):
        if label is not None and not isinstance(label, str):
            raise TypeError("Expected label to be a string")

        self.table_selector: Optional['TableSelectorComponent'] = None
        self.label = label if label else "Select column..."
        self.emulated_row_id: Optional[int] = None
        self.expected_val_type = expected_val_type
        super().__init__(expected_type=str)
        self.emulated_column: str = self.value

    def register_on_table_selector(self, table_selector: 'TableSelectorComponent'):
        """
        Register this ColumnSelector on a TableSelector to specify the table from which a column is being selected
        :param table_selector: The TableSelector representing the table from which a column is being selected
        :return: None
        """
        if not isinstance(table_selector, TableSelectorComponent):
            raise TypeError("Expected table_selector to be a TableSelectorComponent")
        if self.table_selector is not None:
            raise AssertionError("Column must not be added to multiple table selectors")

        self.table_selector = table_selector

    def paint(self):
        """
        Column selectors are not painted by ColumnSelectorComponents, instead they are painted by their registered
        TableSelectorComponents
        :return: ""
        """
        return None

    def set(self, value: Any):
        """
        Overwrite the cell this ColumnSelectorComponent currently represents with value
        Note: This method overwrites data in the actual database, rather than changing a copy of the data this object
        has
        :param value: The value to update the cell with
        :return:
        """
        update_cell(tool=process.running_tool, table=self.table_selector.value, column_name=self.emulated_column,
                    row_id=self.emulated_row_id, value=value)

    def __lshift__(self, other: Any):
        """
        Set the value of the cell this object is currently emulating to other
        Overloads the << operator
        c1 << c2 is equivalent to c1.__lshift__(c2) is equivalent to c1.set(c2)
        :param other: The value to update the cell with
        :return:
        """
        self.set(other)

    class ColumnSelectorIterator:
        """
        An iterator for a given column selector which works by iterating over the results of a select statement querying
        from the associated column

        Attributes:
            vals: A list of vals to iterate over, generated by a select statement at initialization
        """
        def __init__(self, table: sqlalchemy.Table, col_name: str, expected_type: Optional[type] = None):
            if not isinstance(table, sqlalchemy.Table):
                raise TypeError("Expected table to be a sqlalchemy Table")
            if not isinstance(col_name, str):
                raise TypeError("Expected col_name to be a string")
            if expected_type is not None and not isinstance(expected_type, type):
                raise TypeError("Expected expected_type to be None or a type")

            self.table = table
            self.col_name = col_name
            self.expected_type = expected_type

            self.row_id_val_pairs = iterate_over_column(process.running_tool, table, col_name)

        def __iter__(self) -> 'ColumnSelectorIterator':
            return self

        def __next__(self) -> Cell:
            try:
                row_id, val = self.row_id_val_pairs.__next__()
            except StopIteration:
                raise StopIteration

            return Cell(self.table, self.col_name, row_id, self.expected_type, val)

    def __iter__(self) -> ColumnSelectorIterator:
        """
        Return this column selector's iterator, creating a new one if required
        :return:
        """
        if self.table_selector is None:
            raise ValueError("Expected table_selector to not be None to allow iteration")
        if self.table_selector.value is None:
            raise ValueError("Expected associated table selector to have a selected table to allow iteration")
        if self.emulated_column is None:
            raise ValueError("Expected to have an associated column name to allow iteration")

        return ColumnSelectorComponent.ColumnSelectorIterator(
            table=self.table_selector.value,
            col_name=self.emulated_column,
            expected_type=self.expected_val_type
        )


class TableSelectorComponent(InputComponent):
    """
    A component used to list and select a single table

    Attributes:
        label: The label to paint onto this TableSelectorComponent
        template: The template to use to paint this TableSelectorComponent
        columns: A list of ColumnSelectorComponents, each of which select a column from the table associated with this
            TableSelectorComponent
    """
    
    def __init__(self, label: Optional[str] = None, columns: Optional[List[ColumnSelectorComponent]] = None):
        if label is not None and not isinstance(label, str):
            raise TypeError("Expected label to be a string")

        if columns is not None:
            if not isinstance(columns, list):
                raise TypeError("Expected columns to be a list")
            if any([not isinstance(x, ColumnSelectorComponent) for x in columns]):
                raise TypeError("Each element of columns must be ColumnSelector")

        self.label = label if label else "Select table..."

        if config.building_template:
            self.template = config.tool_under_construction.jinja_environment.get_template('table_selector.html')

        self.columns: List[ColumnSelectorComponent] = columns if columns else []
        for column in self.columns:
            column.register_on_table_selector(self)

        super().__init__(expected_type=str)

        # replace value with an actual sqlalchemy Table object if handling post
        if process.handling_post:
            table_name = self.value
            self.value = sqlalchemy.Table(table_name, process.running_tool.db_metadata_obj)
            insp = sqlalchemy.inspect(process.running_tool.db_engine)
            insp.reflect_table(self.value, None)

    def paint(self) -> str:
        """
        Paint this TextComponent as a snippet of HTML
        Also paints the ColumnSelectorComponents in self.columns
        :return: The painted TableSelectorComponent
        """
        tool = config.tool_under_construction
        tables = get_table_names_from_tool(tool)
        table_column_map = {
            table: get_column_names_from_table_name(tool, table)
            for table in tables
        }
        table_column_map_json = json.dumps(table_column_map)

        return self.template.render(
            component=self, 
            tables=tables,
            table_column_map_json=table_column_map_json, 
            column_selectors=self.columns
        )

    class TableSelectorIterator:
        def __init__(self, table: sqlalchemy.Table, rows: Sequence[sqlalchemy.Row]):
            if not isinstance(table, sqlalchemy.Table):
                raise TypeError("Expected table to be a sqlalchemy Table")
            if not isinstance(rows, Sequence):
                raise TypeError("Expected rows to be a sequence")
            if not all([isinstance(r, sqlalchemy.Row) for r in rows]):
                raise TypeError("Expected every item in rows to be a sqlalchemy Row")

            self.table = table
            self.rows_iterator = rows.__iter__()

        def __iter__(self) -> 'TableSelectorIterator':
            return self

        def __next__(self) -> Row:
            try:
                sql_alchemy_row = self.rows_iterator.__next__()
            except StopIteration:
                raise StopIteration

            return Row(table=self.table, sql_alchemy_row=sql_alchemy_row)

    def __iter__(self):
        rows = get_rows_of_table(process.running_tool, self.value)
        return TableSelectorComponent.TableSelectorIterator(table=self.value, rows=rows)
    
    def append(self, other):
        from coolNewLanguage.src.tool import CNLType, Link
        from coolNewLanguage.src.component.user_input_component import UserInputComponent
        mapping = {}
        if self.value is None:
            raise ValueError("Cannot insert into UI table")
        match other:
            case CNLType():
                flatten_fields = CNLType._hls_type_to_field_flattening(other.__class__)
                columns = [n for (n, _) in flatten_fields.items()]
                for (field_name, field) in flatten_fields.items():
                    value = other.__getattribute__(field_name)
                    if value is None and not field.optional:
                        raise ValueError(f"Missing required field {field_name}")
                    if value is None or isinstance(value, Link):
                        continue
                    else:
                        print(value)
                        integral_value = field.type(value)
                    mapping[field_name] = integral_value
                print(mapping)
                pass
            case dict():
                lifted = {}
                for (k, v) in other.items():
                    match v:
                        case UserInputComponent():
                            lifted[k] = v.expected_type(v.value)
                        case _:
                            lifted[k] = v
                mapping = lifted
            case _:
                raise TypeError("Cannot insert unknown type into table")
            
        insert_stmt = sqlalchemy.insert(self.value).values(mapping)
        with process.running_tool.db_engine.connect() as conn:
            conn.execute(insert_stmt)
            conn.commit()

    def delete(self):
        if self.value is None:
            raise ValueError("Cannot insert into UI table")
        self.value.drop(process.running_tool.db_engine)

def create_column_selector_from_table_selector(table: TableSelectorComponent, label: Optional[str] = None):
    """
    Create and return a new ColumnSelectorComponent associated with the passed TableSelectorComponent
    Intended as a convenience method to be used to create new ColumnSelectorComponents after the associated
    TableSelectorComponent has already been created.
    :param table: The TableSelectorComponent to register the new ColumnSelectorComponent on
    :param label: The optional label the created ColumnSelectorComponent will have
    :return: A newly created ColumnSelectorComponent registered on the TableSelectorComponent
    """
    if not isinstance(table, TableSelectorComponent):
        raise TypeError("Expected table to be a TableSelectorComponent")
    if label is not None and not isinstance(label, str):
        raise TypeError("Expected label to be a string")

    col = ColumnSelectorComponent(label)

    col.register_on_table_selector(table)
    table.columns.append(col)

    return col
