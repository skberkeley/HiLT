from typing import Optional

import jinja2
import sqlalchemy

from coolNewLanguage.src import consts
from coolNewLanguage.src.cell import Cell
from coolNewLanguage.src.component.input_component import InputComponent
from coolNewLanguage.src.stage import process, config
from coolNewLanguage.src.util import db_utils


class ColumnSelectorComponent(InputComponent):
    NUM_PREVIEW_COLS = 5
    NUM_PREVIEW_ROWS = 5
    """
    A component which allows one or more columns to be selected interactively from a given selected table
    
    Frontend:
    The initial view of the ColumnSelectorComponent is identical to that of the TableSelectorComponent. When the user 
    selects a table from the previews, a request is made (defined in column_selector.js) which returns the full table,
    which the user then selects columns from. These selected columns are submitted when the stage's POST request is made. 
    The initial template is defined in column_selector.html, while the full table's template is defined in column_selector_full_table.html

    Attributes:
        label: The label to paint onto this ColumnSelectorComponent
        num_columns: The number of columns to select
        table_name: The name of the table from which columns were selected
        value: The names of the column this selector represents
        expected_val_types: The expected type of the values contained in this column
        
    Constants:
        NUM_PREVIEW_COLS: How many columns to show in each table preview
        NUM_PREVIEW_ROWS: How many rows to show in each table preview
    """
    def __init__(self, label: str = "", num_columns: int = 1, expected_val_types: Optional[list[type]] = None):
        if not isinstance(label, str):
            raise TypeError("Expected label to be a string")
        if not isinstance(num_columns, int):
            raise TypeError("Expected num_columns to be an int")
        if expected_val_types is not None and not isinstance(expected_val_types, list):
            raise TypeError("Expected expected_val_types to be None or a list")
        if expected_val_types is not None and not all(isinstance(expected_val_type, type) for expected_val_type in expected_val_types):
            raise TypeError("Expected expected_val_types to be a list of types")

        self.label = label if label else f"Select {num_columns} column{'s' if num_columns > 1 else ''}"
        self.num_columns = num_columns
        self.expected_val_types = expected_val_types
        super().__init__(expected_type=dict)
        if self.value is not None:
            self.table_name = self.value[0]
            self.value: list[str] = self.value[1:]

    def paint(self):
        # Load the jinja template
        template: jinja2.Template = config.tool_under_construction.jinja_environment.get_template(
            name=consts.COLUMN_SELECTOR_COMPONENT_TEMPLATE_FILENAME
        )

        tables = [{"name": table_name} for table_name in
                  db_utils.get_table_names_from_tool(config.tool_under_construction)]
        for i, t in enumerate(tables):
            t["cols"] = db_utils.get_column_names_from_table_name(config.tool_under_construction, t["name"])
            table = db_utils.get_table_from_table_name(config.tool_under_construction, t["name"])
            t["rows"] = db_utils.get_rows_of_table(config.tool_under_construction, table)
            t["transient_id"] = i

        # Render and return the template
        return template.render(
            label=self.label,
            tables=tables,
            num_preview_cols=self.NUM_PREVIEW_COLS,
            num_preview_rows=self.NUM_PREVIEW_ROWS,
            component_id=self.component_id,
            context=consts.GET_TABLE_COLUMN_SELECT
        )

    class ColumnSelectorIterator:
        """
        An iterator for a given column selector which works by iterating over the results of a select statement querying
        from the associated columns

        Attributes:
            vals: A list of vals to iterate over, generated by a select statement at initialization
        """
        def __init__(self, table: sqlalchemy.Table, col_names: list[str], expected_types: list[Optional[type]] = None):
            from coolNewLanguage.src.util.db_utils import iterate_over_columns

            if not isinstance(table, sqlalchemy.Table):
                raise TypeError("Expected table to be a sqlalchemy Table")
            if not isinstance(col_names, list) or not all(isinstance(col_name, str) for col_name in col_names):
                raise TypeError("Expected col_names to be a list of strings")

            self.table = table
            self.col_names = col_names
            self.expected_types = expected_types

            self.row_id_val_pairs = iterate_over_columns(process.running_tool, table, col_names)

        def __next__(self) -> dict[str, Cell]:
            try:
                vals = self.row_id_val_pairs.__next__()
            except StopIteration:
                raise StopIteration

            return {
                self.col_names[i + 1] :
                    Cell(
                        table=self.table,
                        col_name=self.col_names[i + 1],
                        row_id=vals[0],
                        expected_type=self.expected_types[i + 1],
                        val=val
                    )
                for i, val in enumerate(vals)
            }

    def __iter__(self) -> ColumnSelectorIterator:
        """
        Return this column selector's iterator, creating a new one if required
        :return:
        """
        if self.table_name is None:
            raise ValueError("Expected to have a selected table to allow iteration")
        if self.emulated_columns is None:
            raise ValueError("Expected to have associated columns to allow iteration")

        table = db_utils.get_table_from_table_name(process.running_tool, self.table_name)

        return ColumnSelectorComponent.ColumnSelectorIterator(
            table=table,
            col_names=self.emulated_columns,
            expected_types=self.expected_val_types
        )