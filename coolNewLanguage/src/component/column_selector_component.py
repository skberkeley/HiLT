import jinja2
import pandas as pd

from coolNewLanguage.src import consts
from coolNewLanguage.src.component.input_component import InputComponent
from coolNewLanguage.src.stage import process, config


class ColumnSelectorComponent(InputComponent):
    NUM_PREVIEW_COLS = 5
    NUM_PREVIEW_ROWS = 5
    """
    A component which allows one or more columns to be selected interactively from a given selected table
    
    Frontend:
    The initial view of the ColumnSelectorComponent is identical to that of the TableSelectorComponent. When the user 
    selects a table from the previews, a request is made (defined in column_selector.js) which returns the full table,
    which the user then selects columns from. These selected columns are submitted when the stage's POST request is made. 
    The initial template is defined in column_selector.html, while the full table's template is defined in column_selector_full_table.html

    Attributes:
        label: The label to paint onto this ColumnSelectorComponent
        num_columns: The number of columns to select
        table_name: The name of the table from which columns were selected
        value: The names of the column this selector represents
        
    Constants:
        NUM_PREVIEW_COLS: How many columns to show in each table preview
        NUM_PREVIEW_ROWS: How many rows to show in each table preview
    """
    def __init__(self, label: str = "", num_columns: int = 1):
        if not isinstance(label, str):
            raise TypeError("Expected label to be a string")
        if not isinstance(num_columns, int):
            raise TypeError("Expected num_columns to be an int")

        self.label = label if label else f"Select {num_columns} column{'s' if num_columns > 1 else ''}"
        self.num_columns = num_columns

        super().__init__(expected_type=pd.DataFrame)

        if self.value is not None:
            self.table_name: str = self.value[0]
            self.value: pd.DataFrame = process.running_tool.tables[self.table_name][self.value[1:]]

    def paint(self):
        # Load the jinja template
        template: jinja2.Template = config.tool_under_construction.jinja_environment.get_template(
            name=consts.COLUMN_SELECTOR_COMPONENT_TEMPLATE_FILENAME
        )

        tool_tables = config.tool_under_construction.tables
        tables = []
        for i, table_name in enumerate(tool_tables.get_table_names()):
            tables.append(
                {
                    'name': table_name,
                    'cols': tool_tables.get_columns_of_table(table_name),
                    'rows': tool_tables[table_name].head(self.NUM_PREVIEW_ROWS),
                    'transient_id': i
                }
            )

        # Render and return the template
        return template.render(
            label=self.label,
            tables=tables,
            num_preview_cols=self.NUM_PREVIEW_COLS,
            component_id=self.component_id,
            context=consts.GET_TABLE_COLUMN_SELECT
        )

    # class ColumnSelectorIterator:
    #     """
    #     An iterator for a given column selector which works by iterating over the results of a select statement querying
    #     from the associated columns
    #
    #     Attributes:
    #         vals: A list of vals to iterate over, generated by a select statement at initialization
    #     """
    #     def __init__(self, table: sqlalchemy.Table, col_names: list[str], expected_types: list[Optional[type]] = None):
    #         from coolNewLanguage.src.util.db_utils import iterate_over_columns
    #
    #         if not isinstance(table, sqlalchemy.Table):
    #             raise TypeError("Expected table to be a sqlalchemy Table")
    #         if not isinstance(col_names, list) or not all(isinstance(col_name, str) for col_name in col_names):
    #             raise TypeError("Expected col_names to be a list of strings")
    #
    #         self.table = table
    #         self.col_names = col_names
    #         self.expected_types = expected_types
    #
    #         self.row_id_val_pairs = iterate_over_columns(process.running_tool, table, col_names)
    #
    #     def __next__(self) -> dict[str, Cell]:
    #         try:
    #             vals = self.row_id_val_pairs.__next__()
    #         except StopIteration:
    #             raise StopIteration
    #
    #         return {
    #             self.col_names[i + 1] :
    #                 Cell(
    #                     table=self.table,
    #                     col_name=self.col_names[i + 1],
    #                     row_id=vals[0],
    #                     expected_type=self.expected_types[i + 1],
    #                     val=val
    #                 )
    #             for i, val in enumerate(vals)
    #         }
    #
    # def __iter__(self) -> ColumnSelectorIterator:
    #     """
    #     Return this column selector's iterator, creating a new one if required
    #     :return:
    #     """
    #     if self.table_name is None:
    #         raise ValueError("Expected to have a selected table to allow iteration")
    #     if self.emulated_columns is None:
    #         raise ValueError("Expected to have associated columns to allow iteration")
    #
    #     table = process.running_tool.get_table_from_table_name(self.table_name)
    #
    #     return ColumnSelectorComponent.ColumnSelectorIterator(
    #         table=table,
    #         col_names=self.emulated_columns,
    #         expected_types=self.expected_val_types
    #     )