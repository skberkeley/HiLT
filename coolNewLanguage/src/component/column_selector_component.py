from typing import Optional

import jinja2
import sqlalchemy

from coolNewLanguage.src import consts
from coolNewLanguage.src.cell import Cell
from coolNewLanguage.src.component.input_component import InputComponent
from coolNewLanguage.src.stage import process, config
from coolNewLanguage.src.util import db_utils


class ColumnSelectorComponent(InputComponent):
    NUM_PREVIEW_COLS = 5
    NUM_PREVIEW_ROWS = 5
    """
    A component which allows one or more columns to be selected interactively from a given selected table

    Attributes:
        label: The label to paint onto this ColumnSelectorComponent
        num_columns: The number of columns to select
        emulated_columns: The names of the column this selector represents
        expected_val_types: The expected type of the values contained in this column
        
    Constants:
        NUM_PREVIEW_COLS: How many columns to show in each table preview
        NUM_PREVIEW_ROWS: How many rows to show in each table preview
    """
    def __init__(self, label: str = "", num_columns: int = 1, expected_val_types: Optional[list[type]] = None):
        from coolNewLanguage.src.component.table_selector_component import TableSelectorComponent

        if not isinstance(label, str):
            raise TypeError("Expected label to be a string")
        if not isinstance(num_columns, int):
            raise TypeError("Expected num_columns to be an int")
        if expected_val_types is not None and not isinstance(expected_val_types, list):
            raise TypeError("Expected expected_val_types to be None or a list")
        if expected_val_types is not None and not all(isinstance(expected_val_type, type) for expected_val_type in expected_val_types):
            raise TypeError("Expected expected_val_types to be a list of types")

        self.label = label if label else f"Select {num_columns} column{'s' if num_columns > 1 else ''}"
        self.num_columns = num_columns
        self.expected_val_types = expected_val_types
        super().__init__(expected_type=list[str])
        self.emulated_columns: list[str] = self.value

    def paint(self):
        # Load the jinja template
        template: jinja2.Template = config.tool_under_construction.jinja_environment.get_template(
            name=consts.COLUMN_SELECTOR_COMPONENT_TEMPLATE_FILENAME
        )

        tables = [{"name": table_name} for table_name in
                  db_utils.get_table_names_from_tool(config.tool_under_construction)]
        for i, t in enumerate(tables):
            t["cols"] = db_utils.get_column_names_from_table_name(config.tool_under_construction, t["name"])
            table = db_utils.get_table_from_table_name(config.tool_under_construction, t["name"])
            t["rows"] = db_utils.get_rows_of_table(config.tool_under_construction, table)
            t["transient_id"] = i

        # Render and return the template
        return template.render(
            tables=tables,
            num_preview_cols=self.NUM_PREVIEW_COLS,
            num_preview_rows=self.NUM_PREVIEW_ROWS,
            component_id=self.component_id,
            context=consts.GET_TABLE_COLUMN_SELECT
        )

    def register_on_table_selector(self, table_selector: 'TableSelectorComponent'):
        from coolNewLanguage.src.component.table_selector_component import TableSelectorComponent
        """
        Register this ColumnSelector on a TableSelector to specify the table from which a column is being selected
        :param table_selector: The TableSelector representing the table from which a column is being selected
        :return: None
        """
        if not isinstance(table_selector, TableSelectorComponent):
            raise TypeError("Expected table_selector to be a TableSelectorComponent")
        if self.table_selector is not None:
            raise ValueError("This ColumnSelectorComponent is already registered on a TableSelectorComponent")

        self.table_selector = table_selector

    class ColumnSelectorIterator:
        """
        An iterator for a given column selector which works by iterating over the results of a select statement querying
        from the associated column

        Attributes:
            vals: A list of vals to iterate over, generated by a select statement at initialization
        """
        def __init__(self, table: sqlalchemy.Table, col_name: str, expected_type: Optional[type] = None):
            from coolNewLanguage.src.util.db_utils import iterate_over_column

            if not isinstance(table, sqlalchemy.Table):
                raise TypeError("Expected table to be a sqlalchemy Table")
            if not isinstance(col_name, str):
                raise TypeError("Expected col_name to be a string")
            if expected_type is not None and not isinstance(expected_type, type):
                raise TypeError("Expected expected_type to be None or a type")

            self.table = table
            self.col_name = col_name
            self.expected_type = expected_type

            self.row_id_val_pairs = iterate_over_column(process.running_tool, table, col_name)

        def __next__(self) -> Cell:
            try:
                row_id, val = self.row_id_val_pairs.__next__()
            except StopIteration:
                raise StopIteration

            return Cell(self.table, self.col_name, row_id, self.expected_type, val)

    def __iter__(self) -> ColumnSelectorIterator:
        """
        Return this column selector's iterator, creating a new one if required
        :return:
        """
        if self.table_selector is None:
            raise ValueError("Expected table_selector to not be None to allow iteration")
        if self.table_selector.value is None:
            raise ValueError("Expected associated table selector to have a selected table to allow iteration")
        if self.emulated_column is None:
            raise ValueError("Expected to have an associated column name to allow iteration")

        return ColumnSelectorComponent.ColumnSelectorIterator(
            table=self.table_selector.value,
            col_name=self.emulated_column,
            expected_type=self.expected_val_type
        )