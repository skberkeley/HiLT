from typing import Optional, Any

import sqlalchemy

from coolNewLanguage.src.cell import Cell
from coolNewLanguage.src.component.input_component import InputComponent
from coolNewLanguage.src.stage import process
from coolNewLanguage.src.util.db_utils import update_cell, iterate_over_column


class ColumnSelectorComponent(InputComponent):
    """
    A linked, dependent component which allows a column to be selected
    interactively based on a given selected table

    If created before their associated TableSelectorComponent, ColumnSelectors must be passed as a list when the
    TableSelectorComponent is initialized.
    If created after their associated TableSelectorComponent, ColumnSelectors must:
        1. Have the register_on_table_selector(table) method called on the associated TableSelectorComponent
        2. Be appended to the TableSelectorComponent's columns attribute
    For convenience, the create_column_selector_from_table_selector can be used

    Attributes:
        table_selector: The TableSelector representing the table from which a column is being selected
        label: The label to paint onto this ColumnSelector
        emulated_row_id: The id of the row this selector currently represents, used when during execution of certain
            Processors
        emulated_column: The name of the column this selector represents
        expected_val_type: The expected type of the values contained in this column
    """
    def __init__(self, label: Optional[str] = None, expected_val_type: Optional[type] = None):
        from coolNewLanguage.src.component.table_selector_component import TableSelectorComponent

        if label is not None and not isinstance(label, str):
            raise TypeError("Expected label to be a string")

        self.table_selector: Optional[TableSelectorComponent] = None
        self.label = label if label else "Select column..."
        self.emulated_row_id: Optional[int] = None
        self.expected_val_type = expected_val_type
        super().__init__(expected_type=str)
        self.emulated_column: str = self.value

    def register_on_table_selector(self, table_selector: 'TableSelectorComponent'):
        from coolNewLanguage.src.component.table_selector_component import TableSelectorComponent
        """
        Register this ColumnSelector on a TableSelector to specify the table from which a column is being selected
        :param table_selector: The TableSelector representing the table from which a column is being selected
        :return: None
        """
        if not isinstance(table_selector, TableSelectorComponent):
            raise TypeError("Expected table_selector to be a TableSelectorComponent")
        if self.table_selector is not None:
            raise AssertionError("Column must not be added to multiple table selectors")

        self.table_selector = table_selector

    def paint(self):
        """
        Column selectors are not painted by ColumnSelectorComponents, instead they are painted by their registered
        TableSelectorComponents
        :return: ""
        """
        return None

    def set(self, value: Any):
        """
        Overwrite the cell this ColumnSelectorComponent currently represents with value
        Note: This method overwrites data in the actual database, rather than changing a copy of the data this object
        has
        :param value: The value to update the cell with
        :return:
        """
        update_cell(tool=process.running_tool, table=self.table_selector.value, column_name=self.emulated_column,
                    row_id=self.emulated_row_id, value=value)

    def __lshift__(self, other: Any):
        """
        Set the value of the cell this object is currently emulating to other
        Overloads the << operator
        c1 << c2 is equivalent to c1.__lshift__(c2) is equivalent to c1.set(c2)
        :param other: The value to update the cell with
        :return:
        """
        self.set(other)

    class ColumnSelectorIterator:
        """
        An iterator for a given column selector which works by iterating over the results of a select statement querying
        from the associated column

        Attributes:
            vals: A list of vals to iterate over, generated by a select statement at initialization
        """
        def __init__(self, table: sqlalchemy.Table, col_name: str, expected_type: Optional[type] = None):
            if not isinstance(table, sqlalchemy.Table):
                raise TypeError("Expected table to be a sqlalchemy Table")
            if not isinstance(col_name, str):
                raise TypeError("Expected col_name to be a string")
            if expected_type is not None and not isinstance(expected_type, type):
                raise TypeError("Expected expected_type to be None or a type")

            self.table = table
            self.col_name = col_name
            self.expected_type = expected_type

            self.row_id_val_pairs = iterate_over_column(process.running_tool, table, col_name)

        def __iter__(self) -> 'ColumnSelectorIterator':
            return self

        def __next__(self) -> Cell:
            try:
                row_id, val = self.row_id_val_pairs.__next__()
            except StopIteration:
                raise StopIteration

            return Cell(self.table, self.col_name, row_id, self.expected_type, val)

    def __iter__(self) -> ColumnSelectorIterator:
        """
        Return this column selector's iterator, creating a new one if required
        :return:
        """
        if self.table_selector is None:
            raise ValueError("Expected table_selector to not be None to allow iteration")
        if self.table_selector.value is None:
            raise ValueError("Expected associated table selector to have a selected table to allow iteration")
        if self.emulated_column is None:
            raise ValueError("Expected to have an associated column name to allow iteration")

        return ColumnSelectorComponent.ColumnSelectorIterator(
            table=self.table_selector.value,
            col_name=self.emulated_column,
            expected_type=self.expected_val_type
        )